library ieee;
use ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;
Use ieee.std_logic_unsigned.All;

entity DAC_edl is
	port(
	   clk_50MHz : in std_logic;
		Sclk : out std_logic;
		CS : out std_logic;
		reset : in std_logic;
		Din : in std_logic_vector(9 downto 0); 
		SDI : out std_logic;
		LDAC : out std_logic
		--CLK: in std_logic;
		--CLK2: inout std_logic;
		--SCK: out std_logic
	);
end DAC_edl;

architecture behavioral of DAC_edl is

signal clk_int : std_logic:='1';
signal ip_bit	: std_logic_vector (7 downto 0):= x"00";
--signal SEND : std_logic:='1';
--signal i : integer range 0 to 255:=0;
--signal VALUE: std_logic_vector (15 downto 0);	
--signal SENDING : std_logic := '0';
--signal reg : std_logic_vector (15 downto 0);
--
--constant DELAY:integer := 3; -- 50 MHz / 3 == 16.667 MHz
--constant IGNORE:std_logic := '0'; -- 0:use, 1:ignore
--constant BUFFERED:std_logic := '0'; -- 0:unbuffered, 1:buffered
--constant GAIN:std_logic := '1'; -- 0:2X, 1:1X
--constant ACTIVE:std_logic := '1'; -- 0:shutdown, 1:active

signal count : std_logic_vector (7 downto 0):= x"00";
signal counter : std_logic_vector (7 downto 0):= x"00";
signal tx_buf : std_logic_vector (9 downto 0):= x"00";

begin
   
	Sclk <= clk_int;
	
	process(clk_50MHz)  -- Clock divider
	begin									 		 
		if (clk_50MHz'event and clk_50MHz = '0') then
			if(count = x"18") then
				clk_int <= not clk_int;
				count <=  x"00";		
			else
				count <= count + '1';	
			end if;
		end if;	
	end process	;	
	
	--If CS = 0, conversion is initiated
	--If LDAC = 1, DAC is updated with latest digital value
	
	process(clk_int)
	begin
		if(clk_int'event and clk_int = '0') then
			if(CS='1') then
				if(ip_bit >= x"00" and ip_bit <= x"09") then
					tx_buf(to_integer (unsigned (op_bit))) <= Din;
					ip_bit <= ip_bit + '1';
				elsif(ip_bit >= x"0A") then 
					ip_bit <= x"00";
				end if;
			end if;
		end if;	
	end process;
	
	process(clk_int)
	begin
	   if (clk_int'event and clk_int = '0') then
	      if(reset = '0') then
			    counter <= x"00";
				 CS <= '1';
				 LDAC <= '1';  --should this be 1 or 0? As per timing diagram, if everything's idle, then it's 1
			elsif(counter >= x"00" and counter <= x"09") then
				 counter <= counter + '1';
				 CS <= '0';
				 LDAC <= '1';
			elsif(counter >= x"0A") then
				 CS <= '1';
				 LDAC <= '0';
				 counter <= x"00";
			end if;
		end if;
	end process;
	       
--	process(clk_int, SEND) 
--	variable counter : integer range 0 to 15 := 0;	
--	begin
--	
--	if falling_edge(clk_int) then
--		if SEND = '1' then	
--		reg <= IGNORE & BUFFERED & GAIN & ACTIVE & VALUE(15 downto 4);
--		counter := 0;	
--		CS <= '0';
--		SENDING <= '1';
--		SEND <= '0';
--				
--		elsif SENDING = '1' then				
--		reg <= reg(14 downto 0) & '0';		
--			if counter = 15 then		
--			counter := 0;	
--			CS <= '1';
--			SENDING <= '0'; 
--			SEND <= '1';
--			else
--			counter := counter + 1;	
--			end if;
--		end if;			
--	end if;
--		
--	end process;
--	
--Sclk <= clk_int AND SENDING;
--MOSI <= reg(15);
	
end behavioral;